import { firestore } from "firebase-admin";
import TortoiseDocumentReference from "./TortoiseDocumentReference";
import TortoiseQuery from "./TortoiseQuery";
import { TortoiseDataInput, TortoiseUpdateInput } from "../types/TortoiseInput";
import { ObjectKeys } from "../types/ObjectKeys";
import CollectionReference = firestore.CollectionReference;
import Firestore = firestore.Firestore;
import WhereFilterOp = firestore.WhereFilterOp;
import OrderByDirection = firestore.OrderByDirection;


/**
 * Class representing a TortoiseCollectionReference
 * @template T
 */
export default class TortoiseCollectionReference<T> {
  /**
   * collection's path
   * @type {string}
   * @private
   * @readonly
   */
  private readonly path: string;

  /**
   * Firebase collection's reference
   * @type {CollectionReference}
   * @private
   * @readonly
   */
  private readonly collectionRef: CollectionReference;

  /**
   * Firestore instance
   * @type {Firestore}
   * @readonly
   */
  readonly firestore: Firestore;

  /**
   * Create a new TortoiseCollectionReference
   * @param {collectionRef} collectionRef - collection's ref
   * @param {Firestore} firestore - Firestore instance
   */
  constructor(collectionRef: CollectionReference,
              firestore: Firestore) {
    this.collectionRef = collectionRef;
    this.path = collectionRef.path;
    this.firestore = firestore;
  }

  /**
   * Add a new doc in collection
   * @param {T} data - Data for new document
   * @return {Promise<TortoiseDocumentReference<T>>}
   */
  async add(data: TortoiseDataInput<T>): Promise<TortoiseDocumentReference<T>> {
    const rawRef = this.collectionRef.doc();
    const ref = new TortoiseDocumentReference<T>(rawRef, this.firestore);

    await ref.set(data);

    return ref;
  }

  /**
   * Delete collection's documents
   * @return {Promise<true>}
   */
  async delete(): Promise<true> {
    const snaps = await this.collectionRef.get();

    for (const doc of snaps.docs) {
      await doc.ref.delete();
    }

    return true;
  }

  /**
   * Update collection's document
   * @param {TortoiseUpdateInput<T>} updates - Updates to apply
   * @return {Promise<TortoiseDocumentReference<T>[]>}
   */
  async update(updates: TortoiseUpdateInput<T>): Promise<TortoiseDocumentReference<T>[]> {
    const snaps = await this.collectionRef.get();
    const refs: TortoiseDocumentReference<T>[] = [];

    for (const doc of snaps.docs) {
      const docRef = doc.ref;
      const ref = new TortoiseDocumentReference<T>(docRef, this.firestore);
      refs.push(await ref.update(updates));
    }

    return refs;
  }

  /**
   * Get a TortoiseDocumentReference
   * @param {string} [id] - document's id
   * @return {TortoiseDocumentReference<T>}
   */
  doc(id?: string): TortoiseDocumentReference<T> {
    const ref = id ? this.collectionRef.doc(id) : this.collectionRef.doc();
    return new TortoiseDocumentReference<T>(ref, this.firestore);
  }

  /**
   * Retrieve TortoiseDocumentReference from collection
   * @return {Promise<TortoiseDocumentReference<T>[]>}
   */
  async listDocuments(): Promise<TortoiseDocumentReference<T>[]> {
    const snaps = await this.collectionRef.get();
    const refs: TortoiseDocumentReference<T>[] = [];

    for (const doc of snaps.docs) {
      const ref = new TortoiseDocumentReference<T>(doc.ref, this.firestore);
    }

    return refs;
  }

  /**
   * Create a new TortoiseQuery with filter that documents must match
   * @param {ObjectKeys<T>} fieldPath - field's path
   * @param {WhereFilterOp} opStr - Operator to use
   * @param {*} value - Value to match
   * @return {TortoiseQuery<T>}
   */
  where(
    fieldPath: ObjectKeys<T>,
    opStr: WhereFilterOp,
    value: any,
  ): TortoiseQuery<T> {
    const query = this.collectionRef.where(fieldPath, opStr, value);
    return new TortoiseQuery<T>(this.firestore, query);
  }

  /**
   * Return true if provided value is equal to the collection reference
   * @param {*} other - the value to compare against
   * @return {boolean} - Return true if value matches
   */
  isEqual(other: any): boolean {
    return this.collectionRef.isEqual(other);
  }

  /**
   * Creates and returns a new TortoiseQuery instance that apply a field mask to the results
   * @param {ObjectKeys<T>[]} fields - the fields path to return
   * @return {TortoiseQuery<T>}
   */
  select(...fields: ObjectKeys<T>[]): TortoiseQuery<T> {
    const query = this.collectionRef.select(...fields);
    return new TortoiseQuery<T>(this.firestore, query);
  }

  /**
   * Create a TortoiseQuery that's sorted by field and optionally in ascending or descending order
   * @param {ObjectKeys<T>} fieldPath - field to sort on
   * @param {OrderByDirection} [directionStr] - direction to sort
   * @return {TortoiseQuery<T>}
   */
  orderBy(
    fieldPath: ObjectKeys<T>,
    directionStr?: OrderByDirection,
  ): TortoiseQuery<T> {
    const query = this.collectionRef.orderBy(fieldPath, directionStr);
    return new TortoiseQuery<T>(this.firestore, query);
  }

  /**
   * Specifies the offset of the returned results.
   * @param {number} offset
   * @return {TortoiseQuery<T>}
   */
  offset(offset: number): TortoiseQuery<T> {
    const query = this.collectionRef.offset(offset);
    return new TortoiseQuery<T>(this.firestore, query);
  }
}