import { firestore } from "firebase-admin";
import TortoiseDocumentSnapshot from "./TortoiseDocumentSnapshot";
import TortoiseCollectionReference from "./TortoiseCollectionReference";
import { flatten } from "./utils";
import { TortoiseDataInput, TortoiseUpdateInput } from "../types/TortoiseInput";
import DocumentReference = firestore.DocumentReference;
import SetOptions = firestore.SetOptions;
import Firestore = firestore.Firestore;
import { TortoiseDataOptions } from "../types/utils";
import {
  DataResponseWithId,
  DataResponseWithoutId,
  DataWithId,
} from "../types/DataResponse";

/**
 * Class representing a TortoiseDocumentReference
 * @template T
 */
export default class TortoiseDocumentReference<T> {
  /**
   * A firebase document's reference
   * @type {DocumentReference}
   * @readonly
   * @private
   */
  private readonly ref: DocumentReference;

  /**
   * Firestore instance
   * @type {Firestore}
   * @readonly
   */
  readonly firestore: Firestore;

  /**
   * Document's reference id
   * @type {string}
   * @readonly
   */
  readonly id: string;

  /**
   * Document's path
   * @type {string}
   * @readonly
   */
  readonly path: string;

  /**
   * Create a new TortoiseDocumentReference
   * @param {DocumentReference} ref - A firebase document's reference
   * @param {Firestore} firestore - Firestore instance
   */
  constructor(ref: DocumentReference, firestore: Firestore) {
    this.ref = ref;
    this.firestore = firestore;
    this.id = ref.id;
    this.path = ref.path;
  }

  /**
   * Retrieve document's snapshot
   * @return {Promise<TortoiseDocumentSnapshot<T>>}
   */
  async get(): Promise<TortoiseDocumentSnapshot<T>> {
    const snap = await this.ref.get();
    return new TortoiseDocumentSnapshot<T>(snap);
  }

  async data(options: { id: true }): Promise<DataWithId<T>>
  async data(options: { id: false }): Promise<DataResponseWithoutId<T>>
  async data(options?: TortoiseDataOptions): Promise<DataResponseWithoutId<T> | DataResponseWithId<T>>

  /**
   * Retrieve document's data
   * @param {TortoiseDataOptions} [options] - options to set when getting data
   * @param {boolean} [options.id=false]
   * @return {Promise<DataResponseWithoutId<T> | DataWithId<T>>}
   */
  async data(options: TortoiseDataOptions = { id: false }): Promise<DataResponseWithoutId<T> | DataResponseWithId<T>> {
    const rawSnap = await this.ref.get();
    const snap = new TortoiseDocumentSnapshot<T>(rawSnap);

    return snap.data(options);
  }

  /**
   * Update document field
   * @param {TortoiseUpdateInput<T>} updates - updates to apply
   * @throws - Throw error on invalid data format or when document doesn't exist
   * @return {Promise<TortoiseDocumentReference<T>>}
   */
  async update(updates: TortoiseUpdateInput<T>): Promise<TortoiseDocumentReference<T>> {
    const flattenedData = flatten(updates);
    await this.ref.update(flattenedData);
    return this;
  }

  /**
   * Delete current document
   * @return {Promise<true>}
   */
  async delete(): Promise<true> {
    await this.ref.delete();
    return true;
  }

  async set(data: TortoiseDataInput<T>,
            options: SetOptions & { merge: false }): Promise<TortoiseDocumentReference<T>>;
  async set(data: TortoiseUpdateInput<T>,
            options: SetOptions & { merge: true }): Promise<TortoiseDocumentReference<T>>
  async set(data: TortoiseDataInput<T> | TortoiseUpdateInput<T>,
            options?: SetOptions): Promise<TortoiseDocumentReference<T>>;

  /**
   * Set document. If document doesn't exist it create a new one
   * @param {TortoiseDataInput<T> | TortoiseUpdateInput<T>} data - Data for document
   * @param {SetOptions} [options] - options to user with a set operation
   * @param {boolean} [options.merge=false]
   * @return {Promise<TortoiseDocumentReference<T>>}
   */
  async set(data: TortoiseDataInput<T> | TortoiseUpdateInput<T>,
            options: SetOptions = { merge: false }): Promise<TortoiseDocumentReference<T>> {
    const flattenedData = flatten(data);
    await this.ref.set(flattenedData, options);
    return this;
  }

  /**
   * Return a TortoiseCollectionReference
   * @template K
   * @param {string} collectionPath - collection's path
   * @return {TortoiseCollectionReference<K>}
   */
  collection<K>(collectionPath: string): TortoiseCollectionReference<K> {
    const ref = this.ref.collection(collectionPath);
    return new TortoiseCollectionReference<K>(ref, this.firestore);
  }

  /**
   * Return true if provided value is equal to the document reference
   * @param {*} other - the value to compare against
   * @return {boolean} - Return true if value matches
   */
  isEqual(other: any): boolean {
    return this.ref.isEqual(other);
  }
}