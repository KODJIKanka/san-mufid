import { firestore } from "firebase-admin";
import TortoiseDocumentReference from "./TortoiseDocumentReference";
import TortoiseDocumentSnapshot from "./TortoiseDocumentSnapshot";
import { Flatten } from "../types/Flatten";
import { ObjectKeys } from "../types/ObjectKeys";
import Firestore = firestore.Firestore;
import Query = firestore.Query;
import OrderByDirection = firestore.OrderByDirection;
import WriteResult = firestore.WriteResult;
import WhereFilterOp = firestore.WhereFilterOp;

/**
 * Class representing a TortoiseQuery
 * @template T
 */
export default class TortoiseQuery<T> {
  /**
   * A firestore DB
   */
  firestore: Firestore;

  /**
   * A firebase query
   */
  query: Query;

  /**
   * Create a TortoiseQuery
   * @param {Firestore} firestore - A firestore DB
   * @param {Query} query - A firebase query
   */
  constructor(firestore: Firestore, query: Query) {
    this.firestore = firestore;
    this.query = query;
  }

  /**
   * Return TortoiseDocumentSnaps
   * @return {Promise<TortoiseDocumentSnapshot<T>[]>}
   */
  async get(): Promise<TortoiseDocumentSnapshot<T>[]> {
    const rawSnaps = await this.query.get();
    const snaps: TortoiseDocumentSnapshot<T>[] = [];

    for (const raw of rawSnaps.docs) {
      const snap = await raw.ref.get();
      snaps.push(new TortoiseDocumentSnapshot<T>(snap));
    }

    return snaps;
  }

  /**
   * Create a new TortoiseQuery return the first matching document
   * @param {number} limit - Max number of document to match
   * @return {TortoiseQuery<T>}
   *  */
  limit(limit: number) {
    this.query = this.query.limit(limit);
    return this;
  }

  /**
   * Create a TortoiseQuery that's sorted by field and optionally in ascending or descending order
   * @param {ObjectKeys<T>} fieldPath - field to sort on
   * @param {OrderByDirection} [directionStr] - direction to sort
   * @return {TortoiseQuery<T>}
   */
  orderBy(
    fieldPath: ObjectKeys<T>,
    directionStr?: OrderByDirection,
  ): TortoiseQuery<T> {
    this.query = this.query.orderBy(fieldPath, directionStr);
    return this;
  }

  /**
   *  Delete all documents matching query
   * @return {Promise<WriteResult>} - return the last deleted document's write result
   */
  async delete(): Promise<WriteResult> {
    const snaps = await this.query.get();
    let lastWriteResult: WriteResult;

    for (const snap of snaps.docs) {
      lastWriteResult = await snap.ref.delete();
    }

    return lastWriteResult;
  }

  /**
   * Update all documents matching query
   * @param {T} updates - updates to apply
   * @return {Promise<TortoiseDocumentReference<T>[]>}
   */
  async update(
    updates: T,
  ): Promise<TortoiseDocumentReference<T>[]> {
    const snaps = await this.query.get();
    const docRefs: TortoiseDocumentReference<T>[] = [];

    for (const snap of snaps.docs) {
      // @ts-ignore
      await snap.ref.update(updates);
      docRefs.push(new TortoiseDocumentReference<T>(snap.ref, this.firestore));
    }

    return docRefs;
  }

  /**
   * Create a new TortoiseQuery with filter that documents must match
   * @param {ObjectKeys<T>} fieldPath - field's path
   * @param {WhereFilterOp} opStr - Operator to use
   * @param {*} value - Value to match
   * @return {TortoiseQuery<T>}
   */
  where(
    fieldPath: ObjectKeys<T>,
    opStr: WhereFilterOp,
    value: any,
  ): TortoiseQuery<T> {
    this.query = this.query.where(fieldPath, opStr, value);
    return this;
  }

  /**
   * Apply a field mask to the results
   * @param {...(keyof Flatten<T> & string)[]} fields - the fields path to return
   * @return {TortoiseQuery<T>}
   */
  select(...fields: (keyof Flatten<T> & string)[]): TortoiseQuery<T> {
    this.query = this.query.select(...fields);
    return this;
  }

  /**
   * Specifies the offset of the returned results.
   * @param {number} offset
   * @return {TortoiseQuery<T>}
   */
  offset(offset: number): TortoiseQuery<T> {
    this.query = this.query.offset(offset);
    return this;
  }
}